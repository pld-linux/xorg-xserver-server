diff --git a/src/mesa/drivers/dri/r300/r300_ioctl.c b/src/mesa/drivers/dri/r300/r300_ioctl.c
index 90ac988..c4dc97b 100644
--- a/src/mesa/drivers/dri/r300/r300_ioctl.c
+++ b/src/mesa/drivers/dri/r300/r300_ioctl.c
@@ -370,7 +370,7 @@ static void r300Clear(GLcontext * ctx, GLbitfield mask)
 		_swrast_Clear(ctx, mask);
 	}
 
-	swapped = r300->radeon.doPageFlip && (r300->radeon.sarea->pfCurrentPage == 1);
+	swapped = r300->radeon.sarea->pfCurrentPage == 1;
 
 	/* Make sure it fits there. */
 	r300EnsureCmdBufSpace(r300, 421*3, __FUNCTION__);
diff --git a/src/mesa/drivers/dri/r300/r300_vertprog.c b/src/mesa/drivers/dri/r300/r300_vertprog.c
index 52fd1de..e891798 100644
--- a/src/mesa/drivers/dri/r300/r300_vertprog.c
+++ b/src/mesa/drivers/dri/r300/r300_vertprog.c
@@ -883,10 +883,11 @@ static void position_invariant(struct gl_program *prog)
 
 	gl_state_index tokens[STATE_LENGTH] = { STATE_MVP_MATRIX, 0, 0, 0, 0 };
 
+        /* tokens[4] = matrix modifier */
 #ifdef PREFER_DP4
-	tokens[5] = STATE_MATRIX;
+	tokens[4] = 0;  /* not transposed or inverted */
 #else
-	tokens[5] = STATE_MATRIX_TRANSPOSE;
+	tokens[4] = STATE_MATRIX_TRANSPOSE;
 #endif
 	paramList = prog->Parameters;
 
@@ -895,7 +896,7 @@ static void position_invariant(struct gl_program *prog)
 
 	for (i=0; i < 4; i++) {
 		GLint idx;
-		tokens[3] = tokens[4] = i;
+		tokens[2] = tokens[3] = i;  /* matrix row[i]..row[i] */
 		idx = _mesa_add_state_reference(paramList, tokens);
 #ifdef PREFER_DP4
 		vpi[i].Opcode = OPCODE_DP4;
diff --git a/src/mesa/drivers/dri/r300/radeon_context.c b/src/mesa/drivers/dri/r300/radeon_context.c
index 22f943e..9b3f890 100644
--- a/src/mesa/drivers/dri/r300/radeon_context.c
+++ b/src/mesa/drivers/dri/r300/radeon_context.c
@@ -283,7 +283,6 @@ GLboolean radeonMakeCurrent(__DRIcontextPrivate * driContextPriv,
 			radeon->dri.drawable = driDrawPriv;
 
 			radeonSetCliprects(radeon);
-			r300UpdateWindow(radeon->glCtx);
 			r300UpdateViewportOffset(radeon->glCtx);
 		}
 
@@ -293,12 +292,9 @@ GLboolean radeonMakeCurrent(__DRIcontextPrivate * driContextPriv,
 				    (GLframebuffer *) driReadPriv->
 				    driverPrivate);
 
-		if (!radeon->glCtx->Viewport.Width) {
-			_mesa_set_viewport(radeon->glCtx, 0, 0,
-					   driDrawPriv->w, driDrawPriv->h);
-		}
-
 		_mesa_update_state(radeon->glCtx);		
+
+		radeonUpdatePageFlipping(radeon);
 	} else {
 		if (RADEON_DEBUG & DEBUG_DRI)
 			fprintf(stderr, "%s ctx is null\n", __FUNCTION__);
diff --git a/src/mesa/drivers/dri/r300/radeon_lock.c b/src/mesa/drivers/dri/r300/radeon_lock.c
index ec501c3..0d0d9ab 100644
--- a/src/mesa/drivers/dri/r300/radeon_lock.c
+++ b/src/mesa/drivers/dri/r300/radeon_lock.c
@@ -50,16 +50,19 @@ int prevLockLine = 0;
 
 /* Turn on/off page flipping according to the flags in the sarea:
  */
-static void radeonUpdatePageFlipping(radeonContextPtr radeon)
+void radeonUpdatePageFlipping(radeonContextPtr radeon)
 {
 	int use_back;
 
 	radeon->doPageFlip = radeon->sarea->pfState;
         if (radeon->glCtx->WinSysDrawBuffer) {
            driFlipRenderbuffers(radeon->glCtx->WinSysDrawBuffer, radeon->sarea->pfCurrentPage);
+           r300UpdateDrawBuffer(radeon->glCtx);
         }
 
-	use_back = (radeon->glCtx->DrawBuffer->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT);
+	use_back = radeon->glCtx->DrawBuffer ?
+		(radeon->glCtx->DrawBuffer->_ColorDrawBufferMask[0] ==
+		 BUFFER_BIT_BACK_LEFT) : 1;
 	use_back ^= (radeon->sarea->pfCurrentPage == 1);
 
 	if (use_back) {
diff --git a/src/mesa/drivers/dri/r300/radeon_lock.h b/src/mesa/drivers/dri/r300/radeon_lock.h
index 632329f..b11ddf0 100644
--- a/src/mesa/drivers/dri/r300/radeon_lock.h
+++ b/src/mesa/drivers/dri/r300/radeon_lock.h
@@ -41,6 +41,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "radeon_context.h"
 
 extern void radeonGetLock(radeonContextPtr radeon, GLuint flags);
+extern void radeonUpdatePageFlipping(radeonContextPtr radeon);
 
 /* Turn DEBUG_LOCKING on to find locking conflicts.
  */
diff --git a/src/mesa/drivers/dri/r300/radeon_state.c b/src/mesa/drivers/dri/r300/radeon_state.c
index 902e958..82bfd95 100644
--- a/src/mesa/drivers/dri/r300/radeon_state.c
+++ b/src/mesa/drivers/dri/r300/radeon_state.c
@@ -154,7 +154,8 @@ void radeonSetCliprects(radeonContextPtr radeon)
 
 	if (draw_fb->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT) {
 		/* Can't ignore 2d windows if we are page flipping. */
-		if (drawable->numBackClipRects == 0 || radeon->doPageFlip) {
+		if (drawable->numBackClipRects == 0 || radeon->doPageFlip ||
+		    radeon->sarea->pfCurrentPage == 1) {
 			radeon->numClipRects = drawable->numClipRects;
 			radeon->pClipRects = drawable->pClipRects;
 		} else {
diff --git a/src/mesa/drivers/x11/xm_dd.c b/src/mesa/drivers/x11/xm_dd.c
index 543ff69..c854623 100644
--- a/src/mesa/drivers/x11/xm_dd.c
+++ b/src/mesa/drivers/x11/xm_dd.c
@@ -438,7 +438,7 @@ xmesa_DrawPixels_8R8G8B( GLcontext *ctx,
 {
    const SWcontext *swrast = SWRAST_CONTEXT( ctx );
    struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
-   struct xmesa_renderbuffer *xrb = (struct xmesa_renderbuffer *) rb->Wrapped;
+   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb->Wrapped);
 
    if (swrast->NewState)
       _swrast_validate_derived( ctx );
@@ -546,7 +546,7 @@ xmesa_DrawPixels_5R6G5B( GLcontext *ctx,
                          const GLvoid *pixels )
 {
    struct xmesa_renderbuffer *xrb
-      = (struct xmesa_renderbuffer *) ctx->DrawBuffer->_ColorDrawBuffers[0][0];
+      = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0][0]->Wrapped);
    const XMesaContext xmesa = XMESA_CONTEXT(ctx);
    const SWcontext *swrast = SWRAST_CONTEXT( ctx );
    XMesaDisplay *dpy = xmesa->xm_visual->display;
@@ -652,10 +652,10 @@ xmesa_CopyPixels( GLcontext *ctx,
    const SWcontext *swrast = SWRAST_CONTEXT( ctx );
    XMesaDisplay *dpy = xmesa->xm_visual->display;
    const XMesaGC gc = ((XMesaBuffer) ctx->DrawBuffer)->gc;
-   struct xmesa_renderbuffer *srcXrb = (struct xmesa_renderbuffer *)
-      ctx->ReadBuffer->_ColorReadBuffer;
-   struct xmesa_renderbuffer *dstXrb = (struct xmesa_renderbuffer *)
-      ctx->DrawBuffer->_ColorDrawBuffers[0][0];
+   struct xmesa_renderbuffer *srcXrb
+      = xmesa_renderbuffer(ctx->ReadBuffer->_ColorReadBuffer->Wrapped);
+   struct xmesa_renderbuffer *dstXrb
+      = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0][0]->Wrapped);
 
    ASSERT(dpy);
    ASSERT(gc);
diff --git a/src/mesa/shader/arbprogram.c b/src/mesa/shader/arbprogram.c
index 5583f16..4b5f63e 100644
--- a/src/mesa/shader/arbprogram.c
+++ b/src/mesa/shader/arbprogram.c
@@ -1,8 +1,8 @@
 /*
  * Mesa 3-D graphics library
- * Version:  6.5.2
+ * Version:  7.0
  *
- * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
+ * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -703,10 +703,18 @@ _mesa_GetProgramivARB(GLenum target, GLenum pname, GLint *params)
           * The spec says that even if this query returns true, there's
           * no guarantee that the program will run in hardware.
           */
-	 if (ctx->Driver.IsProgramNative) 
+         if (prog->Id == 0) {
+            /* default/null program */
+            *params = GL_FALSE;
+         }
+	 else if (ctx->Driver.IsProgramNative) {
+            /* ask the driver */
 	    *params = ctx->Driver.IsProgramNative( ctx, target, prog );
-	 else
+         }
+	 else {
+            /* probably running in software */
 	    *params = GL_TRUE;
+         }
          return;
       default:
          /* continue with fragment-program only queries below */
diff --git a/src/mesa/shader/prog_execute.c b/src/mesa/shader/prog_execute.c
index 356d4ce..9faf9d8 100644
--- a/src/mesa/shader/prog_execute.c
+++ b/src/mesa/shader/prog_execute.c
@@ -218,120 +218,64 @@ fetch_vector4(const struct prog_src_register *source,
    }
 }
 
-#if 0
+
 /**
- * Fetch the derivative with respect to X for the given register.
- * \return GL_TRUE if it was easily computed or GL_FALSE if we
- * need to execute another instance of the program (ugh)!
+ * Fetch the derivative with respect to X or Y for the given register.
+ * XXX this currently only works for fragment program input attribs.
  */
-static GLboolean
+static void
 fetch_vector4_deriv(GLcontext * ctx,
                     const struct prog_src_register *source,
-                    const SWspan * span,
-                    char xOrY, GLint column, GLfloat result[4])
+                    const struct gl_program_machine *machine,
+                    char xOrY, GLfloat result[4])
 {
-   GLfloat src[4];
+   if (source->File == PROGRAM_INPUT && source->Index < machine->NumDeriv) {
+      const GLint col = machine->CurElement;
+      const GLfloat w = machine->Attribs[FRAG_ATTRIB_WPOS][col][3];
+      const GLfloat invQ = 1.0f / w;
+      GLfloat deriv[4];
 
-   ASSERT(xOrY == 'X' || xOrY == 'Y');
-
-   switch (source->Index) {
-   case FRAG_ATTRIB_WPOS:
       if (xOrY == 'X') {
-         src[0] = 1.0;
-         src[1] = 0.0;
-         src[2] = span->attrStepX[FRAG_ATTRIB_WPOS][2]
-            / ctx->DrawBuffer->_DepthMaxF;
-         src[3] = span->attrStepX[FRAG_ATTRIB_WPOS][3];
+         deriv[0] = machine->DerivX[source->Index][0] * invQ;
+         deriv[1] = machine->DerivX[source->Index][1] * invQ;
+         deriv[2] = machine->DerivX[source->Index][2] * invQ;
+         deriv[3] = machine->DerivX[source->Index][3] * invQ;
       }
       else {
-         src[0] = 0.0;
-         src[1] = 1.0;
-         src[2] = span->attrStepY[FRAG_ATTRIB_WPOS][2]
-            / ctx->DrawBuffer->_DepthMaxF;
-         src[3] = span->attrStepY[FRAG_ATTRIB_WPOS][3];
-      }
-      break;
-   case FRAG_ATTRIB_COL0:
-   case FRAG_ATTRIB_COL1:
-      if (xOrY == 'X') {
-         src[0] = span->attrStepX[source->Index][0] * (1.0F / CHAN_MAXF);
-         src[1] = span->attrStepX[source->Index][1] * (1.0F / CHAN_MAXF);
-         src[2] = span->attrStepX[source->Index][2] * (1.0F / CHAN_MAXF);
-         src[3] = span->attrStepX[source->Index][3] * (1.0F / CHAN_MAXF);
-      }
-      else {
-         src[0] = span->attrStepY[source->Index][0] * (1.0F / CHAN_MAXF);
-         src[1] = span->attrStepY[source->Index][1] * (1.0F / CHAN_MAXF);
-         src[2] = span->attrStepY[source->Index][2] * (1.0F / CHAN_MAXF);
-         src[3] = span->attrStepY[source->Index][3] * (1.0F / CHAN_MAXF);
-      }
-      break;
-   case FRAG_ATTRIB_FOGC:
-      if (xOrY == 'X') {
-         src[0] = span->attrStepX[FRAG_ATTRIB_FOGC][0] * (1.0F / CHAN_MAXF);
-         src[1] = 0.0;
-         src[2] = 0.0;
-         src[3] = 0.0;
+         deriv[0] = machine->DerivY[source->Index][0] * invQ;
+         deriv[1] = machine->DerivY[source->Index][1] * invQ;
+         deriv[2] = machine->DerivY[source->Index][2] * invQ;
+         deriv[3] = machine->DerivY[source->Index][3] * invQ;
       }
-      else {
-         src[0] = span->attrStepY[FRAG_ATTRIB_FOGC][0] * (1.0F / CHAN_MAXF);
-         src[1] = 0.0;
-         src[2] = 0.0;
-         src[3] = 0.0;
+
+      result[0] = deriv[GET_SWZ(source->Swizzle, 0)];
+      result[1] = deriv[GET_SWZ(source->Swizzle, 1)];
+      result[2] = deriv[GET_SWZ(source->Swizzle, 2)];
+      result[3] = deriv[GET_SWZ(source->Swizzle, 3)];
+      
+      if (source->NegateBase) {
+         result[0] = -result[0];
+         result[1] = -result[1];
+         result[2] = -result[2];
+         result[3] = -result[3];
       }
-      break;
-   default:
-      assert(source->Index < FRAG_ATTRIB_MAX);
-      /* texcoord or varying */
-      if (xOrY == 'X') {
-         /* this is a little tricky - I think I've got it right */
-         const GLfloat invQ = 1.0f / (span->attrStart[source->Index][3]
-                                      +
-                                      span->attrStepX[source->Index][3] *
-                                      column);
-         src[0] = span->attrStepX[source->Index][0] * invQ;
-         src[1] = span->attrStepX[source->Index][1] * invQ;
-         src[2] = span->attrStepX[source->Index][2] * invQ;
-         src[3] = span->attrStepX[source->Index][3] * invQ;
+      if (source->Abs) {
+         result[0] = FABSF(result[0]);
+         result[1] = FABSF(result[1]);
+         result[2] = FABSF(result[2]);
+         result[3] = FABSF(result[3]);
       }
-      else {
-         /* Tricky, as above, but in Y direction */
-         const GLfloat invQ = 1.0f / (span->attrStart[source->Index][3]
-                                      + span->attrStepY[source->Index][3]);
-         src[0] = span->attrStepY[source->Index][0] * invQ;
-         src[1] = span->attrStepY[source->Index][1] * invQ;
-         src[2] = span->attrStepY[source->Index][2] * invQ;
-         src[3] = span->attrStepY[source->Index][3] * invQ;
+      if (source->NegateAbs) {
+         result[0] = -result[0];
+         result[1] = -result[1];
+         result[2] = -result[2];
+         result[3] = -result[3];
       }
-      break;
    }
-
-   result[0] = src[GET_SWZ(source->Swizzle, 0)];
-   result[1] = src[GET_SWZ(source->Swizzle, 1)];
-   result[2] = src[GET_SWZ(source->Swizzle, 2)];
-   result[3] = src[GET_SWZ(source->Swizzle, 3)];
-
-   if (source->NegateBase) {
-      result[0] = -result[0];
-      result[1] = -result[1];
-      result[2] = -result[2];
-      result[3] = -result[3];
-   }
-   if (source->Abs) {
-      result[0] = FABSF(result[0]);
-      result[1] = FABSF(result[1]);
-      result[2] = FABSF(result[2]);
-      result[3] = FABSF(result[3]);
-   }
-   if (source->NegateAbs) {
-      result[0] = -result[0];
-      result[1] = -result[1];
-      result[2] = -result[2];
-      result[3] = -result[3];
+   else {
+      ASSIGN_4V(result, 0.0, 0.0, 0.0, 0.0);
    }
-   return GL_TRUE;
 }
-#endif
 
 
 /**
@@ -519,106 +463,6 @@ store_vector4(const struct prog_instruction *inst,
 }
 
 
-#if 0
-/**
- * Initialize a new machine state instance from an existing one, adding
- * the partial derivatives onto the input registers.
- * Used to implement DDX and DDY instructions in non-trivial cases.
- */
-static void
-init_machine_deriv(GLcontext * ctx,
-                   const struct gl_program_machine *machine,
-                   const struct gl_fragment_program *program,
-                   const SWspan * span, char xOrY,
-                   struct gl_program_machine *dMachine)
-{
-   GLuint attr;
-
-   ASSERT(xOrY == 'X' || xOrY == 'Y');
-
-   /* copy existing machine */
-   _mesa_memcpy(dMachine, machine, sizeof(struct gl_program_machine));
-
-   if (program->Base.Target == GL_FRAGMENT_PROGRAM_NV) {
-      /* XXX also need to do this when using valgrind */
-      /* Clear temporary registers (undefined for ARB_f_p) */
-      _mesa_bzero((void *) machine->Temporaries,
-                  MAX_PROGRAM_TEMPS * 4 * sizeof(GLfloat));
-   }
-
-   /* Add derivatives */
-   if (program->Base.InputsRead & FRAG_BIT_WPOS) {
-      GLfloat *wpos = machine->Attribs[FRAG_ATTRIB_WPOS][machine->CurElement];
-      if (xOrY == 'X') {
-         wpos[0] += 1.0F;
-         wpos[1] += 0.0F;
-         wpos[2] += span->attrStepX[FRAG_ATTRIB_WPOS][2];
-         wpos[3] += span->attrStepX[FRAG_ATTRIB_WPOS][3];
-      }
-      else {
-         wpos[0] += 0.0F;
-         wpos[1] += 1.0F;
-         wpos[2] += span->attrStepY[FRAG_ATTRIB_WPOS][2];
-         wpos[3] += span->attrStepY[FRAG_ATTRIB_WPOS][3];
-      }
-   }
-
-   /* primary, secondary colors */
-   for (attr = FRAG_ATTRIB_COL0; attr <= FRAG_ATTRIB_COL1; attr++) {
-      if (program->Base.InputsRead & (1 << attr)) {
-         GLfloat *col = machine->Attribs[attr][machine->CurElement];
-         if (xOrY == 'X') {
-            col[0] += span->attrStepX[attr][0] * (1.0F / CHAN_MAXF);
-            col[1] += span->attrStepX[attr][1] * (1.0F / CHAN_MAXF);
-            col[2] += span->attrStepX[attr][2] * (1.0F / CHAN_MAXF);
-            col[3] += span->attrStepX[attr][3] * (1.0F / CHAN_MAXF);
-         }
-         else {
-            col[0] += span->attrStepY[attr][0] * (1.0F / CHAN_MAXF);
-            col[1] += span->attrStepY[attr][1] * (1.0F / CHAN_MAXF);
-            col[2] += span->attrStepY[attr][2] * (1.0F / CHAN_MAXF);
-            col[3] += span->attrStepY[attr][3] * (1.0F / CHAN_MAXF);
-         }
-      }
-   }
-   if (program->Base.InputsRead & FRAG_BIT_FOGC) {
-      GLfloat *fogc = machine->Attribs[FRAG_ATTRIB_FOGC][machine->CurElement];
-      if (xOrY == 'X') {
-         fogc[0] += span->attrStepX[FRAG_ATTRIB_FOGC][0];
-      }
-      else {
-         fogc[0] += span->attrStepY[FRAG_ATTRIB_FOGC][0];
-      }
-   }
-   /* texcoord and varying vars */
-   for (attr = FRAG_ATTRIB_TEX0; attr < FRAG_ATTRIB_MAX; attr++) {
-      if (program->Base.InputsRead & (1 << attr)) {
-         GLfloat *val = machine->Attribs[attr][machine->CurElement];
-         /* XXX perspective-correct interpolation */
-         if (xOrY == 'X') {
-            val[0] += span->attrStepX[attr][0];
-            val[1] += span->attrStepX[attr][1];
-            val[2] += span->attrStepX[attr][2];
-            val[3] += span->attrStepX[attr][3];
-         }
-         else {
-            val[0] += span->attrStepY[attr][0];
-            val[1] += span->attrStepY[attr][1];
-            val[2] += span->attrStepY[attr][2];
-            val[3] += span->attrStepY[attr][3];
-         }
-      }
-   }
-
-   /* init condition codes */
-   dMachine->CondCodes[0] = COND_EQ;
-   dMachine->CondCodes[1] = COND_EQ;
-   dMachine->CondCodes[2] = COND_EQ;
-   dMachine->CondCodes[3] = COND_EQ;
-}
-#endif
-
-
 /**
  * Execute the given vertex/fragment program.
  *
@@ -762,57 +606,18 @@ _mesa_execute_program(GLcontext * ctx,
          break;
       case OPCODE_DDX:         /* Partial derivative with respect to X */
          {
-#if 0
-            GLfloat a[4], aNext[4], result[4];
-            struct gl_program_machine dMachine;
-            if (!fetch_vector4_deriv(ctx, &inst->SrcReg[0], span, 'X',
-                                     column, result)) {
-               /* This is tricky.  Make a copy of the current machine state,
-                * increment the input registers by the dx or dy partial
-                * derivatives, then re-execute the program up to the
-                * preceeding instruction, then fetch the source register.
-                * Finally, find the difference in the register values for
-                * the original and derivative runs.
-                */
-               fetch_vector4(&inst->SrcReg[0], machine, program, a);
-               init_machine_deriv(ctx, machine, program, span,
-                                  'X', &dMachine);
-               execute_program(ctx, program, pc, &dMachine, span, column);
-               fetch_vector4(&inst->SrcReg[0], &dMachine, program,
-                             aNext);
-               result[0] = aNext[0] - a[0];
-               result[1] = aNext[1] - a[1];
-               result[2] = aNext[2] - a[2];
-               result[3] = aNext[3] - a[3];
-            }
+            GLfloat result[4];
+            fetch_vector4_deriv(ctx, &inst->SrcReg[0], machine,
+                                'X', result);
             store_vector4(inst, machine, result);
-#else
-            store_vector4(inst, machine, ZeroVec);
-#endif
          }
          break;
       case OPCODE_DDY:         /* Partial derivative with respect to Y */
          {
-#if 0
-            GLfloat a[4], aNext[4], result[4];
-            struct gl_program_machine dMachine;
-            if (!fetch_vector4_deriv(ctx, &inst->SrcReg[0], span, 'Y',
-                                     column, result)) {
-               init_machine_deriv(ctx, machine, program, span,
-                                  'Y', &dMachine);
-               fetch_vector4(&inst->SrcReg[0], machine, program, a);
-               execute_program(ctx, program, pc, &dMachine, span, column);
-               fetch_vector4(&inst->SrcReg[0], &dMachine, program,
-                             aNext);
-               result[0] = aNext[0] - a[0];
-               result[1] = aNext[1] - a[1];
-               result[2] = aNext[2] - a[2];
-               result[3] = aNext[3] - a[3];
-            }
+            GLfloat result[4];
+            fetch_vector4_deriv(ctx, &inst->SrcReg[0], machine,
+                                'Y', result);
             store_vector4(inst, machine, result);
-#else
-            store_vector4(inst, machine, ZeroVec);
-#endif
          }
          break;
       case OPCODE_DP3:
diff --git a/src/mesa/shader/prog_execute.h b/src/mesa/shader/prog_execute.h
index 47845e9..be29ece 100644
--- a/src/mesa/shader/prog_execute.h
+++ b/src/mesa/shader/prog_execute.h
@@ -48,6 +48,9 @@ struct gl_program_machine
 
    /** Fragment Input attributes */
    GLfloat (*Attribs)[MAX_WIDTH][4];
+   GLfloat (*DerivX)[4];
+   GLfloat (*DerivY)[4];
+   GLuint NumDeriv; /**< Max index into DerivX/Y arrays */
    GLuint CurElement; /**< Index into Attribs arrays */
 
    /** Vertex Input attribs */
diff --git a/src/mesa/shader/slang/slang_codegen.c b/src/mesa/shader/slang/slang_codegen.c
index c6151f8..cf32b50 100644
--- a/src/mesa/shader/slang/slang_codegen.c
+++ b/src/mesa/shader/slang/slang_codegen.c
@@ -700,37 +700,6 @@ _slang_find_node_type(slang_operation *oper, slang_operation_type type)
 }
 
 
-/**
- * Produce inline code for a call to an assembly instruction.
- * XXX Note: children are passed as asm args in-order, not by name!
- */
-static slang_operation *
-slang_inline_asm_function(slang_assemble_ctx *A,
-                          slang_function *fun, slang_operation *oper)
-{
-   const GLuint numArgs = oper->num_children;
-   const slang_operation *args = oper->children;
-   GLuint i;
-   slang_operation *inlined = slang_operation_new(1);
-
-   /*assert(oper->type == SLANG_OPER_CALL);  or vec4_add, etc */
-   /*
-   printf("Inline asm %s\n", (char*) fun->header.a_name);
-   */
-   inlined->type = fun->body->children[0].type;
-   inlined->a_id = fun->body->children[0].a_id;
-   inlined->num_children = numArgs;
-   inlined->children = slang_operation_new(numArgs);
-   inlined->locals->outer_scope = oper->locals->outer_scope;
-
-   for (i = 0; i < numArgs; i++) {
-      slang_operation_copy(inlined->children + i, args + i);
-   }
-
-   return inlined;
-}
-
-
 static void
 slang_resolve_variable(slang_operation *oper)
 {
@@ -892,6 +861,70 @@ slang_substitute(slang_assemble_ctx *A, slang_operation *oper,
 
 
 /**
+ * Produce inline code for a call to an assembly instruction.
+ * This is typically used to compile a call to a built-in function like this:
+ *
+ * vec4 mix(const vec4 x, const vec4 y, const vec4 a)
+ * {
+ *    __asm vec4_lrp __retVal, a, y, x;
+ * }
+ *
+ * We basically translate a SLANG_OPER_CALL into a SLANG_OPER_ASM.
+ */
+static slang_operation *
+slang_inline_asm_function(slang_assemble_ctx *A,
+                          slang_function *fun, slang_operation *oper)
+{
+   const GLuint numArgs = oper->num_children;
+   GLuint i;
+   slang_operation *inlined;
+   const GLboolean haveRetValue = _slang_function_has_return_value(fun);
+   slang_variable **substOld;
+   slang_operation **substNew;
+
+   ASSERT(slang_is_asm_function(fun));
+   ASSERT(fun->param_count == numArgs + haveRetValue);
+
+   /*
+   printf("Inline %s as %s\n",
+          (char*) fun->header.a_name,
+          (char*) fun->body->children[0].a_id);
+   */
+
+   /*
+    * We'll substitute formal params with actual args in the asm call.
+    */
+   substOld = (slang_variable **)
+      _slang_alloc(numArgs * sizeof(slang_variable *));
+   substNew = (slang_operation **)
+      _slang_alloc(numArgs * sizeof(slang_operation *));
+   for (i = 0; i < numArgs; i++) {
+      substOld[i] = fun->parameters->variables[i];
+      substNew[i] = oper->children + i;
+   }
+
+   /* make a copy of the code to inline */
+   inlined = slang_operation_new(1);
+   slang_operation_copy(inlined, &fun->body->children[0]);
+   if (haveRetValue) {
+      /* get rid of the __retVal child */
+      for (i = 0; i < numArgs; i++) {
+         inlined->children[i] = inlined->children[i + 1];
+      }
+      inlined->num_children--;
+   }
+
+   /* now do formal->actual substitutions */
+   slang_substitute(A, inlined, numArgs, substOld, substNew, GL_FALSE);
+
+   _slang_free(substOld);
+   _slang_free(substNew);
+
+   return inlined;
+}
+
+
+/**
  * Inline the given function call operation.
  * Return a new slang_operation that corresponds to the inlined code.
  */
diff --git a/src/mesa/shader/slang/slang_ir.c b/src/mesa/shader/slang/slang_ir.c
index 9517bdf..a6903cc 100644
--- a/src/mesa/shader/slang/slang_ir.c
+++ b/src/mesa/shader/slang/slang_ir.c
@@ -63,7 +63,7 @@ static const slang_ir_info IrInfo[] = {
    { IR_ABS, "IR_ABS", OPCODE_ABS, 4, 1 },
    { IR_NEG, "IR_NEG", OPCODE_NOP, 4, 1 }, /* special case: emit_negation() */
    { IR_DDX, "IR_DDX", OPCODE_DDX, 4, 1 },
-   { IR_DDX, "IR_DDY", OPCODE_DDX, 4, 1 },
+   { IR_DDY, "IR_DDY", OPCODE_DDY, 4, 1 },
    { IR_SIN, "IR_SIN", OPCODE_SIN, 1, 1 },
    { IR_COS, "IR_COS", OPCODE_COS, 1, 1 },
    { IR_NOISE1, "IR_NOISE1", OPCODE_NOISE1, 1, 1 },
diff --git a/src/mesa/swrast/s_aalinetemp.h b/src/mesa/swrast/s_aalinetemp.h
index 402d64b..80cec0b 100644
--- a/src/mesa/swrast/s_aalinetemp.h
+++ b/src/mesa/swrast/s_aalinetemp.h
@@ -93,7 +93,7 @@ NAME(plot)(GLcontext *ctx, struct LineInfo *line, int ix, int iy)
       attribArray[i][0] = solve_plane(fx, fy, line->sPlane[attr]) * invQ;
       attribArray[i][1] = solve_plane(fx, fy, line->tPlane[attr]) * invQ;
       attribArray[i][2] = solve_plane(fx, fy, line->uPlane[attr]) * invQ;
-      if (attr < FRAG_ATTRIB_VAR0) {
+      if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
          const GLuint unit = attr - FRAG_ATTRIB_TEX0;
          line->span.array->lambda[unit][i]
             = compute_lambda(line->sPlane[attr],
@@ -220,7 +220,7 @@ NAME(line)(GLcontext *ctx, const SWvertex *v0, const SWvertex *v1)
          compute_plane(line.x0, line.y0, line.x1, line.y1, t0, t1, line.tPlane[attr]);
          compute_plane(line.x0, line.y0, line.x1, line.y1, r0, r1, line.uPlane[attr]);
          compute_plane(line.x0, line.y0, line.x1, line.y1, q0, q1, line.vPlane[attr]);
-         if (attr < FRAG_ATTRIB_VAR0) {
+         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
             const GLuint u = attr - FRAG_ATTRIB_TEX0;
             const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
             const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
diff --git a/src/mesa/swrast/s_aatritemp.h b/src/mesa/swrast/s_aatritemp.h
index 39456cc..4162ed6 100644
--- a/src/mesa/swrast/s_aatritemp.h
+++ b/src/mesa/swrast/s_aatritemp.h
@@ -203,7 +203,7 @@
          compute_plane(p0, p1, p2, t0, t1, t2, tPlane[attr]);
          compute_plane(p0, p1, p2, r0, r1, r2, uPlane[attr]);
          compute_plane(p0, p1, p2, q0, q1, q2, vPlane[attr]);
-         if (attr < FRAG_ATTRIB_VAR0) {
+         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
             const GLuint u = attr - FRAG_ATTRIB_TEX0;
             const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
             const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
@@ -289,7 +289,7 @@
                array->attribs[attr][count][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
                array->attribs[attr][count][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
                array->attribs[attr][count][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
-               if (attr < FRAG_ATTRIB_VAR0) {
+               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                   const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                   array->lambda[unit][count] = compute_lambda(sPlane[attr], tPlane[attr],
                                                               vPlane[attr], cx, cy, invQ,
@@ -381,7 +381,7 @@
                array->attribs[attr][ix][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
                array->attribs[attr][ix][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
                array->attribs[attr][ix][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
-               if (attr < FRAG_ATTRIB_VAR0) {
+               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                   const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                   array->lambda[unit][ix] = compute_lambda(sPlane[attr],
                                                            tPlane[attr],
diff --git a/src/mesa/swrast/s_fragprog.c b/src/mesa/swrast/s_fragprog.c
index 882fec2..b150122 100644
--- a/src/mesa/swrast/s_fragprog.c
+++ b/src/mesa/swrast/s_fragprog.c
@@ -113,8 +113,14 @@ init_machine(GLcontext *ctx, struct gl_program_machine *machine,
    /* Setup pointer to input attributes */
    machine->Attribs = span->array->attribs;
 
-   /* Store front/back facing value in register FOGC.Y */
-   machine->Attribs[FRAG_ATTRIB_FOGC][col][1] = (GLfloat) ctx->_Facing;
+   machine->DerivX = (GLfloat (*)[4]) span->attrStepX;
+   machine->DerivY = (GLfloat (*)[4]) span->attrStepY;
+   machine->NumDeriv = FRAG_ATTRIB_MAX;
+
+   if (ctx->Shader.CurrentProgram) {
+      /* Store front/back facing value in register FOGC.Y */
+      machine->Attribs[FRAG_ATTRIB_FOGC][col][1] = (GLfloat) ctx->_Facing;
+   }
 
    machine->CurElement = col;
 
diff --git a/src/mesa/swrast/s_pointtemp.h b/src/mesa/swrast/s_pointtemp.h
index d118a53..dddc2f7 100644
--- a/src/mesa/swrast/s_pointtemp.h
+++ b/src/mesa/swrast/s_pointtemp.h
@@ -275,7 +275,7 @@ NAME ( GLcontext *ctx, const SWvertex *vert )
 #if FLAGS & ATTRIBS
             ATTRIB_LOOP_BEGIN
                COPY_4V(span->array->attribs[attr][count], attrib[attr]);
-               if (attr < FRAG_ATTRIB_VAR0) {
+               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                   const GLuint u = attr - FRAG_ATTRIB_TEX0;
                   span->array->lambda[u][count] = 0.0;
                }
diff --git a/src/mesa/swrast/s_span.c b/src/mesa/swrast/s_span.c
index 0b17791..097d2c7 100644
--- a/src/mesa/swrast/s_span.c
+++ b/src/mesa/swrast/s_span.c
@@ -1357,7 +1357,11 @@ shade_texture_span(GLcontext *ctx, SWspan *span)
       if ((inputsRead >= FRAG_BIT_VAR0) && (span->interpMask & SPAN_VARYING))
          interpolate_varying(ctx, span);
 
+#if 0
       if (inputsRead & FRAG_BIT_WPOS)
+#else
+      /* XXX always interpolate wpos so that DDX/DDY work */
+#endif
          interpolate_wpos(ctx, span);
 
       /* Run fragment program/shader now */
diff --git a/src/mesa/swrast/s_tritemp.h b/src/mesa/swrast/s_tritemp.h
index b8601bd..dcc3e95 100644
--- a/src/mesa/swrast/s_tritemp.h
+++ b/src/mesa/swrast/s_tritemp.h
@@ -1,6 +1,6 @@
 /*
  * Mesa 3-D graphics library
- * Version:  6.5.3
+ * Version:  7.0
  *
  * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
  *
@@ -499,7 +499,7 @@ static void NAME(GLcontext *ctx, const SWvertex *v0,
 #  endif /* GL_FLOAT */
 #  ifdef INTERP_ALPHA
          span.attrStepX[FRAG_ATTRIB_COL0][3] = oneOverArea * (eMaj_da * eBot.dy - eMaj.dy * eBot_da);
-         span.attrStepX[FRAG_ATTRIB_COL0][3] = oneOverArea * (eMaj.dx * eBot_da - eMaj_da * eBot.dx);
+         span.attrStepY[FRAG_ATTRIB_COL0][3] = oneOverArea * (eMaj.dx * eBot_da - eMaj_da * eBot.dx);
 #    if CHAN_TYPE == GL_FLOAT
          span.alphaStep = span.attrStepX[FRAG_ATTRIB_COL0][3];
 #    else
@@ -523,7 +523,7 @@ static void NAME(GLcontext *ctx, const SWvertex *v0,
 	 span.blueStep  = 0;
 #    endif /* GL_FLOAT */
 #  ifdef INTERP_ALPHA
-         span.attrStepX[FRAG_ATTRIB_COL0][3] = span.attrStepX[FRAG_ATTRIB_COL0][3] = 0.0F;
+         span.attrStepX[FRAG_ATTRIB_COL0][3] = span.attrStepY[FRAG_ATTRIB_COL0][3] = 0.0F;
 #    if CHAN_TYPE == GL_FLOAT
 	 span.alphaStep = 0.0F;
 #    else
@@ -893,11 +893,11 @@ static void NAME(GLcontext *ctx, const SWvertex *v0,
 #  endif
 #  ifdef INTERP_ALPHA
 #    if CHAN_TYPE == GL_FLOAT
-                  aLeft = vLower->color[ACOMP] + (span.attrStepX[FRAG_ATTRIB_COL0][3] * adjx + span.attrStepX[FRAG_ATTRIB_COL0][3] * adjy) * (1.0F / FIXED_SCALE);
-                  fdaOuter = span.attrStepX[FRAG_ATTRIB_COL0][3] + dxOuter * span.attrStepX[FRAG_ATTRIB_COL0][3];
+                  aLeft = vLower->color[ACOMP] + (span.attrStepX[FRAG_ATTRIB_COL0][3] * adjx + span.attrStepY[FRAG_ATTRIB_COL0][3] * adjy) * (1.0F / FIXED_SCALE);
+                  fdaOuter = span.attrStepY[FRAG_ATTRIB_COL0][3] + dxOuter * span.attrStepX[FRAG_ATTRIB_COL0][3];
 #    else
                   aLeft = (GLint)(ChanToFixed(vLower->color[ACOMP]) + span.attrStepX[FRAG_ATTRIB_COL0][3] * adjx + span.attrStepX[FRAG_ATTRIB_COL0][3] * adjy) + FIXED_HALF;
-                  fdaOuter = SignedFloatToFixed(span.attrStepX[FRAG_ATTRIB_COL0][3] + dxOuter * span.attrStepX[FRAG_ATTRIB_COL0][3]);
+                  fdaOuter = SignedFloatToFixed(span.attrStepY[FRAG_ATTRIB_COL0][3] + dxOuter * span.attrStepX[FRAG_ATTRIB_COL0][3]);
 #    endif
 #  endif
                }
diff --git a/src/mesa/swrast_setup/ss_context.c b/src/mesa/swrast_setup/ss_context.c
index 360cc61..3f6d294 100644
--- a/src/mesa/swrast_setup/ss_context.c
+++ b/src/mesa/swrast_setup/ss_context.c
@@ -131,8 +131,10 @@ setup_vertex_format(GLcontext *ctx)
       if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR_INDEX ))
          EMIT_ATTR( _TNL_ATTRIB_COLOR_INDEX, EMIT_1F, index );
 
-      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG ))
-         EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1F, attrib[FRAG_ATTRIB_FOGC]);
+      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
+         const GLint emit = ctx->FragmentProgram._Current ? EMIT_4F : EMIT_1F;
+         EMIT_ATTR( _TNL_ATTRIB_FOG, emit, attrib[FRAG_ATTRIB_FOGC]);
+      }
 
       if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX))
       {
@@ -261,7 +263,7 @@ _swsetup_Translate( GLcontext *ctx, const void *vertex, SWvertex *dest )
    dest->win[2] = m[10] * tmp[2] + m[14];
    dest->win[3] =         tmp[3];
 
-
+   /** XXX try to limit these loops someday */
    for (i = 0 ; i < ctx->Const.MaxTextureCoordUnits ; i++)
       _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0+i,
                      dest->attrib[FRAG_ATTRIB_TEX0 + i] );
@@ -282,6 +284,7 @@ _swsetup_Translate( GLcontext *ctx, const void *vertex, SWvertex *dest )
    _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR_INDEX, tmp );
    dest->index = tmp[0];
 
+   /* XXX See _tnl_get_attr about pointsize ... */
    _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_POINTSIZE, tmp );
    dest->pointSize = tmp[0];
 }
diff --git a/src/mesa/tnl/t_vb_program.c b/src/mesa/tnl/t_vb_program.c
index 81e166b..9961af7 100644
--- a/src/mesa/tnl/t_vb_program.c
+++ b/src/mesa/tnl/t_vb_program.c
@@ -126,6 +126,8 @@ init_machine(GLcontext *ctx, struct gl_program_machine *machine)
       }
    }
 
+   machine->NumDeriv = 0;
+
    /* init condition codes */
    machine->CondCodes[0] = COND_EQ;
    machine->CondCodes[1] = COND_EQ;
diff --git a/src/mesa/tnl/t_vertex.c b/src/mesa/tnl/t_vertex.c
index c666b38..6aae602 100644
--- a/src/mesa/tnl/t_vertex.c
+++ b/src/mesa/tnl/t_vertex.c
@@ -229,7 +229,15 @@ void _tnl_get_attr( GLcontext *ctx, const void *vin,
 
    /* Else return the value from ctx->Current.
     */
-   _mesa_memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
+   if (attr == _TNL_ATTRIB_POINTSIZE) {
+      /* If the hardware vertex doesn't have point size then use size from
+       * GLcontext.  XXX this will be wrong if drawing attenuated points!
+       */
+      dest[0] = ctx->Point._Size;
+   }
+   else {
+      _mesa_memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
+   }
 }
 
 
